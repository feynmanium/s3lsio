var searchIndex = {};
searchIndex["s3lsio"] = {"doc":"If you want a configuration file to store options so that you don&#39;t want to pass those in\neach time then create a subdirectory in your home directory:\n```mkdir ~/.s3lsio```\nCreate a TOML file called config:\n```vim ~/.s3lsio/config```\nAdd the following options (optional):\n[options]\nendpoint = &quot;&lt;whatever endpoint you want&gt;&quot;\nproxy = &quot;&lt;whatever your proxy url with port if you use a proxy&gt;&quot;\nsignature = &quot;V4&quot;","items":[[3,"Error","s3lsio","Allows you to control Error output.",null,null],[12,"format","","Defaults to OutputFormat::serialize since it&#39;s easier to debug.",0,null],[12,"color","","Can be any term color. Defaults to term::color::RED.",0,null],[3,"Output","","Allows you to control non-Error output.",null,null],[12,"format","","Defaults to OutputFormat::plain.",1,null],[12,"color","","Can be any term color. Defaults to term::color::GREEN.",1,null],[3,"BenchOutput","","Allows you to control Benchmarking output.",null,null],[12,"format","","Defaults to OutputFormat::plain.",2,null],[12,"color","","Can be any term color. Defaults to term::color::GREEN.",2,null],[3,"BenchOperation","","Allows for duration tracking of operations. You should not track time of this app running but\nof each operation and then the summation of the durations plus latency etc.",null,null],[12,"start_time","","Time operation occured",3,null],[12,"end_time","","",3,null],[12,"request","","Request (endpoint + path)",3,null],[12,"endpoint","","Endpoint URL",3,null],[12,"method","","GET, PUT, DELETE...",3,null],[12,"success","","If the operation succeeded or not",3,null],[12,"code","","HTTP return code",3,null],[12,"payload_size","","Size of payload",3,null],[12,"duration","","Duration of operation",3,null],[12,"object","","Object name",3,null],[3,"BenchThreadSummary","","A summary of all of the operations for a given thread",null,null],[12,"thread_name","","",4,null],[12,"total_requests","","",4,null],[12,"total_success","","",4,null],[12,"total_errors","","",4,null],[12,"total_duration","","",4,null],[12,"total_payload","","",4,null],[12,"total_throughput","","",4,null],[12,"operations","","",4,null],[3,"BenchThread","","",null,null],[12,"thread_name","","",5,null],[12,"total_requests","","",5,null],[12,"total_success","","",5,null],[12,"total_errors","","",5,null],[12,"total_duration","","",5,null],[12,"total_payload","","",5,null],[12,"total_throughput","","",5,null],[3,"BenchHostInstanceSummary","","A summary of all threads on a given node/instance",null,null],[12,"host_instance","","",6,null],[12,"ip_address","","",6,null],[12,"start_time","","",6,null],[12,"end_time","","",6,null],[12,"total_requests","","",6,null],[12,"total_success","","",6,null],[12,"total_errors","","",6,null],[12,"total_duration","","",6,null],[12,"total_payload","","",6,null],[12,"total_throughput","","",6,null],[12,"total_threads","","",6,null],[12,"host_duration","","",6,null],[12,"operations","","",6,null],[3,"BenchSummary","","A summary of all of the hosts used in the benchmarking process.",null,null],[12,"start_time","","",7,null],[12,"end_time","","",7,null],[12,"total_requests","","",7,null],[12,"total_success","","",7,null],[12,"total_errors","","",7,null],[12,"total_duration","","",7,null],[12,"total_payload","","",7,null],[12,"total_host_instances","","",7,null],[12,"total_threads","","",7,null],[12,"total_throughput","","",7,null],[12,"operations","","",7,null],[3,"BenchRequest","","Metadata for the Benchmarking request.",null,null],[12,"date_time","","",8,null],[12,"description","","",8,null],[12,"report","","",8,null],[12,"iterations","","",8,null],[12,"duration","","",8,null],[12,"virtual_users","","",8,null],[12,"request_type","","",8,null],[12,"size","","",8,null],[12,"nodes","","",8,null],[3,"BenchResults","","Allows for duration tracking of operations. You should not track time of this app running but\nof each operation and then the summation of the durations plus latency etc.",null,null],[12,"request","","",9,null],[12,"summary","","",9,null],[3,"Client","","Client structure holds a reference to the ```S3Client``` which also implements two traits:\n```AwsCredentialsProvider``` and ```DispatchSignedRequest```\nSince ```S3Client``` struct is takes those two traits as parameters then ALL functions called\nthat require passing in ```S3Client``` or Client must specify the trait signature as follows:\nExample: fn ```whatever_function```&lt;P: ```AwsCredentialsProvider```, D: ```DispatchSignedRequest```&gt;(client: &amp;mut Client&lt;P,D&gt;)\nNote: Could also specify &#39;where&#39; P:... D:... instead.",null,null],[12,"s3client","","",10,null],[12,"config","","",10,null],[12,"error","","",10,null],[12,"output","","",10,null],[12,"is_quiet","","",10,null],[12,"is_time","","",10,null],[12,"is_bench","","",10,null],[12,"bench","","",10,null],[4,"OutputFormat","","Allows you to set the output type for stderr and stdout.",null,null],[13,"CSV","","",11,null],[13,"JSON","","",11,null],[13,"PrettyJSON","","",11,null],[13,"Plain","","",11,null],[13,"Serialize","","",11,null],[13,"Simple","","",11,null],[13,"None","","",11,null],[13,"NoneAll","","",11,null],[4,"Commands","","Commands",null,null],[13,"abort","","",12,null],[13,"acl","","",12,null],[13,"cp","","",12,null],[13,"get","","",12,null],[13,"head","","",12,null],[13,"mb","","",12,null],[13,"put","","",12,null],[13,"range","","",12,null],[13,"rb","","",12,null],[13,"rm","","",12,null],[13,"ls","","",12,null],[13,"setacl","","",12,null],[13,"setver","","",12,null],[13,"stats","","",12,null],[13,"ver","","",12,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"eq","","",11,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"eq","","",12,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"benchoperation"}}],[11,"clone","","",3,null],[11,"encode","","",3,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"encode","","",4,null],[11,"new","","",4,{"inputs":[{"name":"benchthread"},{"name":"vec"}],"output":{"name":"benchthreadsummary"}}],[11,"fmt","","",5,null],[11,"default","","",5,{"inputs":[],"output":{"name":"benchthread"}}],[11,"clone","","",5,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"encode","","",6,null],[11,"new","","",6,{"inputs":[{"name":"vec"}],"output":{"name":"benchhostinstancesummary"}}],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"encode","","",7,null],[11,"new","","",7,{"inputs":[{"name":"vec"}],"output":{"name":"benchsummary"}}],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"encode","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"encode","","",9,null],[11,"new","","",9,{"inputs":[{"name":"benchrequest"},{"name":"benchsummary"}],"output":{"name":"benchresults"}}]],"paths":[[3,"Error"],[3,"Output"],[3,"BenchOutput"],[3,"BenchOperation"],[3,"BenchThreadSummary"],[3,"BenchThread"],[3,"BenchHostInstanceSummary"],[3,"BenchSummary"],[3,"BenchRequest"],[3,"BenchResults"],[3,"Client"],[4,"OutputFormat"],[4,"Commands"]]};
initSearch(searchIndex);
